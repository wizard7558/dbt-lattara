# Reference this view as omni_dbt__facebook_ads_performance
schema_label: ""

schema: omni_dbt
table_name: FACEBOOK_ADS_PERFORMANCE

dimensions:
  date:
    sql: '"DATE"'

  account:
    sql: '"ACCOUNT"'

  campaign:
    sql: '"CAMPAIGN"'

  adset:
    sql: '"ADSET"'

  ad:
    sql: '"AD"'

  ad_id:
    sql: '"AD_ID"'
    format: ID

  conversionname:
    sql: '"CONVERSIONNAME"'

  spend:
    sql: '"SPEND"'

  impressions:
    sql: '"IMPRESSIONS"'

  clicks:
    sql: '"CLICKS"'

  allconv:
    sql: '"ALLCONV"'

  is_optimization_conversion:
    sql: '"IS_OPTIMIZATION_CONVERSION"'

measures:
  count:
    aggregate_type: count

#The info below was pulled from your dbt repository and is read-only.
dbt:
  name: facebook_ads_performance
  target_schema: PROD
  config:
    materialized: table
  code: |-
    {{config(materialized = "table")}} 

    SELECT CAST(f.DATE AS DATE) AS DATE
         , f.ACCOUNT
         , f.CAMPAIGN
         , f.ADSET
         , f.AD
         , f.AD_ID
         , f.CONVERSIONNAME
         , f.SPEND_RAW/f.DIVIDEND AS SPEND
         , f.IMPRESSIONS_RAW/f.DIVIDEND AS IMPRESSIONS
         , f.CLICKS_RAW/f.DIVIDEND AS CLICKS
         , f.ALLCONV
         , CASE WHEN oc.optimization_conversion IS NOT NULL THEN TRUE ELSE FALSE END AS IS_OPTIMIZATION_CONVERSION
    FROM {{ ref('int_facebook_conversions') }} f
    LEFT JOIN {{ ref('optimization_conversions') }} oc
        ON f.ACCOUNT = oc.account
        AND f.CONVERSIONNAME = oc.optimization_conversion
        AND oc.platform = 'facebook'
    ORDER BY DATE DESC
         , CAMPAIGN ASC
         , ADSET ASC
         , AD ASC
         , CONVERSIONNAME ASC
  referenced_by: [ all_ads_performance, all_spend_by_account, domain_money_meta_creatives ]
